preprocess_dir = config["elvers_directories"]["preprocess"]
pear_dir = os.path.join(out_dir, config['pear']['output_dir'])

pear_params = config['pear']['params']

def get_fastp_trimmed_pe_only(w):
    readsD = {}
    if not is_single_end(**w):
        readsD['r1'] = os.path.os.path.join(input_dir, f'{w.sample}_1.fastp.fq.gz')
        readsD['r2'] = os.path.os.path.join(input_dir, f'{w.sample}_2.fastp.fq.gz')
        return readsD
    return readsD

rule pear_read_merging:
    """
    Merge PE reads with PEAR, for input into PALADIN
	"""
    input:
        unpack(get_fastp_trimmed_pe_only)
    output: 
        assembled = os.path.join(pear_dir, '{sample}.pear_assembled.fq.gz'),
        discarded = os.path.join(pear_dir, '{sample}.pear_discarded.fq.gz'),
        unassembled_r1 = os.path.join(pear_dir, '{sample}.pear_unassembled_r1.fq.gz'),
        unassembled_r2 = os.path.join(pear_dir, '{sample}.pear_unassembled_r2.fq.gz'),
    message:
        """--- Merging paired reads using PEAR  ---"""
    params:
        pval = pear_params.get('pval',"0.01"),
        max_memory = pear_params.get('max_memory', "4G"),
        extra = pear_params.get('extra', '')
    threads: 6
    log: os.path.join(logs_dir, 'pear/{sample}.log')
    benchmark: os.path.join(benchmarks_dir, 'pear/{sample}.benchmark')
    conda: 'environment.yml'
    script: 'pear-wrapper.py'
